spring:
  application:
    name: toolschallenge

  # Configuração do DataSource (PostgreSQL)
  datasource:
    url: jdbc:postgresql://localhost:5432/pagamentos
    username: postgres
    password: postgres
    driver-class-name: org.postgresql.Driver
    hikari:
      maximum-pool-size: 10
      minimum-idle: 5
      connection-timeout: 30000

  # JPA/Hibernate
  jpa:
    database-platform: org.hibernate.dialect.PostgreSQLDialect
    hibernate:
      ddl-auto: validate  # Flyway gerencia o schema, não o Hibernate
    show-sql: false
    properties:
      hibernate:
        format_sql: true
        jdbc:
          time_zone: UTC

  # Flyway (Migrações)
  flyway:
    enabled: true
    baseline-on-migrate: true
    locations: classpath:db/migration

  # Redis (Idempotência e Cache)
  data:
    redis:
      host: localhost
      port: 6379
      password: redis123
      timeout: 2000ms

  # Kafka
  kafka:
    bootstrap-servers: localhost:9092
    consumer:
      group-id: pagamentos-group
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: br.com.sicredi.toolschallenge
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer

# Actuator (Monitoramento)
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus,circuitbreakers,circuitbreakerevents
      base-path: /atuador
  endpoint:
    health:
      show-details: always
  prometheus:
    metrics:
      export:
        enabled: true
  # Distributed Tracing (Micrometer → Jaeger via Zipkin endpoint)
  tracing:
    sampling:
      probability: 1.0  # 100% sampling para desenvolvimento
  zipkin:
    tracing:
      endpoint: http://localhost:9411/api/v2/spans  # Jaeger Zipkin-compatible endpoint

# Resilience4j (Circuit Breaker, Retry, Bulkhead)
resilience4j:
  circuitbreaker:
    instances:
      adquirente:
        # Percentual de falhas para abrir o circuito
        failure-rate-threshold: 50
        # Janela de chamadas para calcular taxa de falha
        sliding-window-size: 10
        # Número mínimo de chamadas antes de calcular taxa
        minimum-number-of-calls: 5
        # Tempo em OPEN antes de tentar HALF_OPEN
        wait-duration-in-open-state: 10s
        # Chamadas permitidas em HALF_OPEN para teste
        permitted-number-of-calls-in-half-open-state: 3
        # Transição automática para HALF_OPEN após wait-duration
        automatic-transition-from-open-to-half-open-enabled: true
        # Registra eventos no Actuator
        register-health-indicator: true

  retry:
    instances:
      adquirente:
        # Número máximo de tentativas (1 original + 2 retries)
        max-attempts: 3
        # Intervalo entre tentativas
        wait-duration: 500ms
        # Exceções que devem acionar retry
        retry-exceptions:
          - br.com.sicredi.toolschallenge.shared.exception.ServicoIndisponivelException
          - java.net.ConnectException
          - java.net.SocketTimeoutException

  bulkhead:
    instances:
      adquirente:
        # Tipo thread pool (isola threads da aplicação)
        max-thread-pool-size: 10
        core-thread-pool-size: 5
        # Fila de espera quando threads estão ocupadas
        queue-capacity: 20
        # Timeout para aguardar thread disponível
        keep-alive-duration: 20ms

# Configuração do Adquirente Simulado
# NOTA: Chaos Engineering desabilitado para MVP
# Para testar resiliência, altere failure-rate/timeout-rate para valores > 0
adquirente:
  simulado:
    # Taxa de falhas (0.0 a 1.0) - 0.0 = sem falhas (MVP)
    failure-rate: 0.0
    # Latência artificial em ms (simula lentidão realista)
    latency-ms: 100
    # Taxa de timeouts extremos (0.0 a 1.0) - 0.0 = sem timeouts (MVP)
    timeout-rate: 0.0
    # Taxa de aprovação quando disponível (1.0 = 100% aprovado para MVP)
    aprovacao-rate: 1.0

# Configuração de Reprocessamento de Transações Pendentes
reprocessamento:
  # Habilita/desabilita o scheduler de reprocessamento
  enabled: true
  # Intervalo entre execuções em minutos (padrão: 5 minutos)
  intervalo-minutos: 5
  # Número máximo de registros processados por batch (limita carga)
  batch-size: 50
  # Número máximo de tentativas antes de enviar para DLQ
  max-tentativas: 3

# OpenAPI/Swagger
springdoc:
  api-docs:
    path: /v3/api-docs
  swagger-ui:
    path: /swagger-ui.html
    enabled: true

# JWT (Autenticação)
jwt:
  # Chave secreta para assinatura HS256 (DEVE ser variável de ambiente em produção!)
  # IMPORTANTE: Gerar chave aleatória de 256+ bits (32+ caracteres)
  # Exemplo de geração: openssl rand -base64 32
  secret: "toolschallenge-secret-key-change-in-production-256bits-minimum"
  # Expiração do token: 30 dias (2592000000ms)
  expiration-ms: 2592000000
  # Issuer (emissor do token)
  issuer: "toolschallenge-api"

# Logging
logging:
  level:
    root: INFO
    br.com.sicredi.toolschallenge: DEBUG
    org.springframework.web: INFO
    org.springframework.kafka: WARN
    org.apache.kafka: WARN
    org.hibernate: INFO
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
